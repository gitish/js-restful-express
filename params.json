{
  "name": "Js-restful-express",
  "tagline": "Create a RESTful service with ES7 decorators for your express based node.js application.",
  "body": "# js-restful-express\r\nCreate a RESTful service with ES7 decorators for your express based node.js application.\r\n\r\n\r\n[![CI Status](http://img.shields.io/travis/mseemann/js-restful-express.svg?style=flat)](https://travis-ci.org/mseemann/js-restful-express)\r\n[![npm version](https://badge.fury.io/js/js-restful-express.svg)](http://badge.fury.io/js/js-restful-express)\r\n[![Downloads](http://img.shields.io/npm/dm/js-restful-express.svg)](https://npmjs.org/package/js-restful-express)\r\n[![Coverage Status](https://coveralls.io/repos/github/mseemann/js-restful-express/badge.svg?branch=master)](https://coveralls.io/github/mseemann/js-restful-express?branch=master)\r\n[![Code Climate](https://codeclimate.com/github/mseemann/js-restful-express/badges/gpa.svg)](https://codeclimate.com/github/mseemann/js-restful-express)\r\n[![Test Coverage](https://codeclimate.com/github/mseemann/js-restful-express/badges/coverage.svg)](https://codeclimate.com/github/mseemann/js-restful-express/coverage)\r\n[![Issue Count](https://codeclimate.com/github/mseemann/js-restful-express/badges/issue_count.svg)](https://codeclimate.com/github/mseemann/js-restful-express)\r\n[![Issue Stats](http://issuestats.com/github/mseemann/js-restful-express/badge/issue)](http://issuestats.com/github/mseemann/js-restful-express)\r\n\r\n## Installation\r\n```bash\r\nnpm install js-restful-express --save\r\n```\r\nThis module requires reflect-metadata as a peer dependency. This is essential to make the decorators working. It must be ensured\r\nthat this module is only loaded once. Otherwise the decorated information will be lost at runtime. Keep in mind that this is\r\na shim and until now not a language feature!\r\n\r\n## Prerequisites\r\n- You use TypeScript for your app\r\n- You use express 4.x as your http framework for your node.js application\r\n\r\n## Usage\r\nDecorate your service class with the decorators from the [js-restful](https://github.com/mseemann/js-restful) Github-project.\r\nSo far there are the following decorators available:\r\n\r\n|   Decorator   |   Description |\r\n| ------------- | ------------- |\r\n| @Path         | The path under which the service will be published. The decorator can be used at class and method level. You need to provide a path as string.|\r\n| @GET          | Decorator that indicates a HTTP GET method.|\r\n| @POST         | Decorator that indicates a HTTP POST method.|\r\n| @PUT          | Decorator that indicates a HTTP PUT method.|\r\n| @DELETE       | Decorator that indicates a HTTP DELETE method.|\r\n| @PathParam    | A method parameter may be decorated with the `@PathParam` decorator. The decorator reuquires a string parameter - the name of the parameter. The name must be present within the Path. For example `/books/:id`. One can access the id parameter parameter with `@PathParam('id')`|\r\n| @HeaderParam  | You can access the http header information in the same way as a path parameter. The difference is, that the value will be determined by a http header entry at runtime. For example if you want to access a token that is stored in the http header use: `@HeaderParam('token)`|\r\n| @QueryParam   | If you want to access url query parameters from your service use this decorator. For example in a url like this: `/books?readed=true` you can use `@QueryParam('readed')`|\r\n| @Context (HttpRequest, HttpResponse)  | Sometime it may be necessary to play around with the original HttpRequest or the HttpResponse. In this case you can use the `@Context` decorator. For Example `@Context(ContextTpyes.HttpRequest)`|\r\n| @SecurityContext  | This module provides decorators that can deal with security concerns out of the box. If this doesn't fits your needs you can inject the SecurityContext manually. For example: `withSecContext(@SecurityContext() context:ISecurityContext)` |\r\n| @RolesAllowed | You may restrict the access to all methods of a class or a specific method. Just use the `@RolesAllowed` decorator: `@RolesAllowed(['admin'])`|\r\n| @PermitAll    | If you want you service or service methods to be called by everyone use `@PermitAll`|\r\n\r\n#### Remarks\r\n- The HTTP Method decorators are only marker decorators. They don't have a parameter. The request path must be defined by the `@Path` decorator.\r\n- If you use any of the build in security capabilities you need to register a `ISecurityContextFactory`. See below.\r\n- If you specify `@RolesAllowed` or `@PermitAll` at class level and method level, the decorator at the method overwrites the decorator at class level.\r\n\r\nThis npm modul adds the following decorators:\r\n\r\n|   Decorator   |   Description |\r\n| ------------- | ------------- |\r\n| @RenderWith   | The decorator expects a string as parameter. This is the view that should be used to render the result. For example: `@RenderWith('index')` will render the result of the service method with a view named `index`. You need to configure express with your preferred render engine: `app.set('view engine', 'pug');`. |\r\n| @ExpressContext (HttpNextFunction) | The express framework provides a `next` function. If you need access to this function from within your service you may use this decorator for a method parameter. |\r\n\r\n\r\nA more elaborate example:\r\n\r\n```typescript\r\nimport { GET, POST, PUT, DELETE, Path, PathParam, HeaderParam } from 'js-restful';\r\n\r\n\r\n@Path('/books')\r\nclass BookService {\r\n\r\n    @GET()\r\n    allBooks() : Book[]{\r\n       return [];\r\n    }\r\n\r\n    @Path('/:name')\r\n    @POST()\r\n    createBook(@PathParam('name') name:string, @HeaderParam('token') token:string) :Book {\r\n        return {id:1, name:name};\r\n    }\r\n\r\n    @Path('/:id/:name')\r\n    @PUT()\r\n    updateBook(@PathParam('id') id:number, @PathParam('name') name:string) : Book {\r\n        return {id:id, name:name};\r\n    }\r\n\r\n    @Path('/:id')\r\n    @DELETE()\r\n    deleteBook(@PathParam('id') id:number): boolean {\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\nAfter you have done this, setup your express app as you usually would. Then you can register a decorated instance of your service:\r\n\r\n```TypeScript\r\nimport { ExpressServiceRegistry } from './service-registry';\r\nimport * as express from 'express';\r\n\r\nlet app = express();\r\nExpressServiceRegistry.registerService(app, new BookService());\r\n```\r\nThat's it. Now your service is published as an RESTful service in your express app.\r\n\r\nIf you start your app you can access the urls:\r\n<pre>\r\nGET     /books                      -> []\r\nPOST    /books/simpsons             -> {id:1, name:'simpsons'}\r\nPUT     /books/1/Huckleberry Finn   -> {id:1, name:'Huckleberry Finn'}\r\nDELETE  /books/1                    -> true\r\n</pre>\r\n\r\n## Supported Return Types\r\n\r\nSo far we have seen that all servcie methods are synchronous. You can return simple javascript types or complex objects.\r\nIf you simply return a boolean, number, string these values will be returned as text/plain. null or undefined are\r\nreturned as text/plain if no HttpResponse-object is injected in the service method (in this case you have full control what should be returned to the client).\r\nIf you returns a complex object the result will be send as application/json.\r\n\r\nBut what if your service method is asynchronous? In this case you can use es6 promises. For example:\r\n\r\n```TypeScript\r\nimport {Promise} from 'es6-promise';\r\n\r\n@Path('/')\r\nclass TestService {\r\n\r\n    @GET()\r\n    get(){\r\n        const p: Promise<any> = new Promise ((resolve, reject) => {\r\n          resolve([{foo:'bar'}]);\r\n        });\r\n        return p;\r\n    }\r\n}\r\n```\r\nIf you access the url '/' you will get `[{foo:'bar'}]` as the result. May be this is too much code for you - for me it is :smirk: .\r\nKeep in mind that there are a lot of node modules that already use promisses. For example mongoose. With this you service could be as short as:\r\n\r\n```TypeScript\r\nimport {Path, GET, RolesAllowed} from 'js-restful';\r\nimport {User} from './../models/userModel';\r\n\r\n@Path('/users')\r\n@RolesAllowed(['admin'])\r\nexport class UserService {\r\n\r\n  @GET()\r\n  users(){\r\n    return User.find({}).exec();\r\n  }\r\n\r\n}\r\n```\r\n\r\n## Providing a ISecurityContextFactory\r\nIf you decorate your service with `@RolesAllowed`, `@PermitAll` or you are using `@SecurityContext` as a parameter\r\ndecorator you need to provide a `ISecurityContextFactory`. js-rstful-express need this factory to create a `ISecurityContext` to decide who is permitted to access\r\nthe service or service method.\r\n\r\nThis Factory must be registered at the `ExpressServiceRegistry` before you register your service classes:\r\n```TypeScript\r\nExpressServiceRegistry.registerSecurityContextFactory(app, new SecurityContextFactory());\r\n```\r\nHere is a sample implementation that assumes you are using passport for authentication:\r\n\r\n```TypeScript\r\nclass SecurityContextFactory implements ISecurityContextFactory {\r\n\r\n  createSecurityContext(req:express.Request):ISecurityContext {\r\n    return new SecurityContext(req);\r\n  }\r\n\r\n}\r\n```\r\nThe `SecurityContext` needs to be created for every request!\r\n```TypeScript\r\nclass SecurityContext implements ISecurityContext {\r\n\r\n  user:User;\r\n\r\n  constructor(req:express.Request){\r\n    this.user = new User(req);\r\n  }\r\n\r\n  isUserInRole(roleName:string):boolean {\r\n    if(!this.user.isLoggedIn()){\r\n      return false;\r\n    }\r\n    return this.user.hasRole(roleName);\r\n  }\r\n}\r\n```\r\n```TypeScript\r\nexport default class User implements IUser {\r\n\r\n  private passportUser:any;\r\n  private roles:string[] = [];\r\n\r\n  constructor(req:express.Request){\r\n\r\n    if (req.isAuthenticated()){\r\n      this.passportUser = req.user;\r\n    }\r\n  }\r\n\r\n  isLoggedIn():boolean{\r\n    return this.passportUser ? true : false;\r\n  }\r\n\r\n  hasRole(roleName:string):boolean {\r\n    return this.passportUser.roles.indexOf(roleName) != -1;\r\n  }\r\n}\r\n```\r\n\r\n## Advantages\r\nYou may ask: what is the advantage of using decorators and TypeScript for your app? Here are some thoughts why it is useful:\r\n\r\n- You may write less code you need to maintain and test.\r\n- You can refactor your code with minimal impact at other parts of your application. Just move or rename your service class will not break how your service may be accessed.\r\n- You can change who is allowed to access your service or service method without modifying your code. You just change the decorator.\r\n- You can test your services more easily - if you do not use HttpReqest or HttpResponse directly you don't need to mock these objects.\r\n- May be you have a background in Java and know what [JAX-RS](https://jax-rs-spec.java.net) is. In this case you will be familiar with this approach.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}